PROCESSES, EXECUTION, AND STATE

A process is an object with state/operations. Is an executing instance of a program.
A process layout in memory:
	statically sized code segments
	data that grows up from beginning of address
	stack that grows down from end of address

	Code segments are read from the load module into the virtual address space. They are read/execute only and sharable so other processes can use them.

	Data segments are read/write, and private to its process. It grows and shrinks with the sbrk() system call.

	Stack is local variables, global variables, parameters, registers.
		-grows w/ nested function calls
		-managed by OS
		-can be dynamically extended
		-created at the same time as a data segment
		-read/write, but not executable, private to its process

The state of a process is its registers (PC, stack pointer, program status word, stack pointer, etc.), and its address space.
	Process descriptors are OS data structures for describing state. The Linux Process Control Block is an example.
	Not all of the state is stored in these descriptors, though.

Processes are created by OS at the request of other processes. They need process descriptors stored in a process table. They need address spaces allocated by the OS for the code/data/stack.

When making a new process, you can start w/ a blank process and fill in the blanks (Windows)
Or you could give it the same stuff as the old process (Unix/Linux fork())
	fork avoids the cost of opying a lot of code
	It's easy to manage shared resources and set up pipes.
	The child and parent share code, but not data/stack
	The child only copies data if it needs to write to it - "copy on write" - because data is big.
	fork was made before pthreads. 

exec() is reserved for when you don't want a copy of the same process.

Once we have a load module, we load it to memory by copying code to memory, and then we execute.

Terminating processes:
	OS must reclaim resources the process is holding, inform other processes waiting on this one, and remove the process descriptor from the process table.

To run a process on a CPU core, hardware is initialized, registers are loaded, stack is initialized, PC is set. And we do it with limited direct execution.

Exceptions
	When a process can't run an instruction, an exception is made.
	Can be routine (overflow) or asynchronous (^C, a seg fault)
	We deal with the latter w/ try/catch or traps.

	Call a trap?
		trap vector table -> find a 1st level handler -> enter OS through trap gate,
		go to a system call dispatch table -> 2nd level handler performs sys call -> return to user mode

There is a separate supervisor kernel stack.
The user stack is pushed onto it when going into kernel.

Signal Handling
	-ignore signal
	-designate a handler
	-default action (kill process)

	Signals are implemented by the OS, work like trap/interrupt.

Some processes are blocked because they are known not to be chosen, or they are waiting for a resource. A resource manager handles most blocking/unblocking.
We swap processes when resources are tight, when memory gets full. Swapping means moving process' state to a secondary storage and blocking process descriptors.