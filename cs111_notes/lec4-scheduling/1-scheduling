SCHEDULING

We have a queue of processes ready to run.
Goal: maximize throughput, minimize average waiting time, ensure fairness, meet priority goals, meet deadlines.

Types of Systems
	time sharing - fast repsonse for interactive programs, each user gets equal share of CPU
	batch - maximize throughput, delays are unimportant
	real-time - critical operations must happen on time, noncritical operations may never happen

Preemptive scheduling
	-allow interrupts
	-good response time
	-fair
	-good w realtime and priority scheduling
	-complex context switches
	-might get bad throughput

Nonpreemptive scheduling
	-low overhead
	-high throughput
	-simple
	-unfair, can get caught in infinite loop
	-good for simple systems with small amount of processes
	-bad w realtime and prioirity scheduling

How to measure performance? throughput (processes/sec)? turnaround time? response time?

A process' life:
	time spent running - determined by process
	time spent waiting for resource - determined by resource manager
	time spent waiting to run - determined by scheduling

Impossible to reach ideal throughput due to the overhead of dispatching processes.
When load gets too big, jobs are dropped, leading to infinite response time.

What should we do when we're overloaded?
	Continue service w degraded performance?
	or
	Reject new tasks, wait for load to return to normal.

	Do NOT allow throughput to drop to 0 or response time will explode.

nonpreemptive - FIFO, SJF, real time schedulers
FIFO
	-used in batch systems where response time is unimportant.
	-also used in embedded systems w brief computations or a natural producer/consumer relationship.
realtime schedulers
	-hard deadlines are mandatory. soft deadlines are preferred.
	-for hard deadlines, you work out a schedule ahead of time, knowing the length of all tasks, and you avoid non-deterministic behavior and so there are no interrupts or decisions at runtime.
	-for soft deadlines, we allow preemption, and do the earliest deadline first

preemptive - RR
	hard to share resources. saving states for context switches is expensive. but it's fair.

context switch
	Enter OS - take interrupt, save registers, call scheduler
	Scheduler chooses tasks.
	OS switches stack, process descriptor, address space.
	Lose instruction and data caches, slowing next hundred instructions.

MLFQ - good response time overall, fair CPU use, predictable response time, dynamic adjustments