CONCURRENCY PROBLEMS

Non Deadlock Bugs
	Atomicity Violation
		Ex: Thread 1 checks if reference is NULL, and if it not, uses it. Thread 2 interrupts after check and sets to NULL.

		We assume something is atomic, but it is interrupted before it could finish the "atomic operation".
		Fix it with locks.

	Order Violation
		Ex: Thread 1 sets a value and Thread 2 uses it. But Thread 2 goes first when we assumed otherwise.

		We assume threads will go in a certain order, but they don't.
		Fix it with condition variables.

Deadlock Bugs
	Thread 1 holds lock L1 and is waiting for lock L2 to be released.
	Thread 2 holds lock L2 and is waiting for lock L1 to be released.

	Deadlocks come about because with large amounts of code there are complex dependencies.
	They especially come about because of encapsulation, and so we don't know the implementations.

	4 Conditions for Deadlocks to Happen
		Mutual exclusion
		Hold-and-wait - threads hold the resources allocated to them while waiting on other resources
		No preemption
		Circular wait - there exists a circular chain of threads, where each holds at least one resource that the next is waiting on

Preventing Deadlock Conditions
	Preventing Circular Wait
		Provide a "total ordering" of lock acquisition.
		If a thread wishes to acquire L1 and L2, all thread must acquire L1 and then L2 in that order.
		"partial ordering" is when you apply ordering to a subset of all the locks.

	Preventing Hold and Wait
		Acquire all your locks at once, and add a lock for acquiring all those locks at once.

	Preventing no Preemption
		pthread_mutex_trylock() grabs a lock if it's available, but continues if it's not. And thus instead of holding and waiting, if the try fails, release whatever locks the thread is holding.
		But this leads to "livelock", where programs will run but still get nothing done, so same problem. It's a bit unlikely, since it would mean the threads would both be trying and releasing over and over again at exact times.
		It's also tricky releasing your locks in a careful manner.

Deadlock Avoidance Via Scheduling
	Avoidance as opposed to prevention means knowing global knowledge as to what threads get what locks, and scheduling those threads to make deadlock impossible. Threads that can deadlock each other will be put on their own processor, and can only run on that one.

Detect and Recover
	If deadlocks are rare, this is a practical solution. Let deadlocks happen and when they do, somehow detect it and then perform an action.