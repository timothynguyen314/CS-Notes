DEADLOCKS

Types of Resources
	Commodity Resources
		Clients need an amount, and deadlocks occur when we run out.
		A resource manager is thus needed.
	General Resources
		Clients need a specific instance, and deadlocks occur from specific dependency relationships.
		Avoid deadlocks at design time.

Conditions for Deadlocks
	Mutual Exclusion
	Incremental Allocation
		Fix by giving whenever someone asks
		Or a thread gets their resources all-or-none
	No Preemption
	Circular Waiting
		There's a cycle in a graph of resource requests
		Fix by having a fixed order for getting multiple resources across processes

Avoiding Deadlocks - Reservations
	Resource manager keeps track of reservations, only reserving when there's space, and thus avoids oversubscription of resources.
	Overbooking vs Under-Utilization, since processes generally over-reserve?
	Allocation failure occurs at reservation time, and the application must continue running afterwards

	When memory is full, a swap manager is needed to swap out processes...but it needs to allocate memory for requests.
	So we should pre-allocate request blocks ahead of time.

Deadlock Prevention
	Avoiding is making sure no lock causes a deadlock.
	Prevention is making sure a particular lock doesn't cause a deadlock by attacking one of the four conditions.

	Mutual Exclusion
		Make resources shareable, ie reader/writer locks?
		Give each process their own private resources?
	Incremental Allcoation
		Allocate all resources in a single operation
		Also a thread can't be blocked if it's holding locks, must release before being blocked
	No Preemption
		We can fix this by pulling out the resources and forcing locks to break.
		This must be enforced by invalidating the thread's resource handle.
		Revocation, however, is it not possible when the process has direct access to the object, such as when the object is part of the process' address space, because revoking means destroying an addres space.
	Circular Dependencies
		Use "total ordering" for resources.

		Lock Dances
			A lockable list head followed by lockable buffers
			To access any buffer, you must first lock the head, lock your buffer, then unlock the head

Detection and Recovery
	Sometimes we just let deadlocks happen, if deadlocks are rare.
	Maintain a data structur that keeps track of locks.
	This can be complex, and sometimes it isn't clear what to do when you get a deadlock.

Health Monitoring
	A monitor periodically reports status.
	If a response takes too long, the service is declared "hung".
	Easier to implement.
	Can also detect other problems, ie livelock, priority inversion.

	What to do after Failure
		Know which processes to kill/restart, and the effects such would have.
		Should the thread keep retrying? Continue w reduced functionality? Report an error? Restart?

How to make Synchronization easier
	We want encapsulation, so developers don't need to identify critical sections.
	Each monitor should have a semaphore to lock/unlock upon use
	Monitor locking
		Coarse-grained - lock an entire object on any method, but this could lead to bottleneck performance issues
		Fine-grained - difficult and error prone
	In Java, each object has an associated mutex, and locks on synchronized methods. This is fine-grained, and it's up to the developer to choose the right methods to avoid deadlocks.

