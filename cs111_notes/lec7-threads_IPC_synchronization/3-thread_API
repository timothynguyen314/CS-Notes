THREAD API

PTHREADS

	#include <pthread.h>
	int
	pthread_create(	pthread_t*				thread,
					const pthread_attr_t*	attr,
					void*					(*start_routine) (void *),
					void*					arg);

	thread will be the pthread associated with the pthread created by this function.
	attr is adding an attribute. Usually passing the default, NULL, is fine.
	(*start_routine) is the function pointer, the function the pthread continues in--the thread returns a void pointer.
	arg is an argument you can pass into *start_routine--it can be any type, but by default is void*.

	int
	pthread_join(	pthread_t	thread,
					void**		value_ptr);

	thread is the thread we wait for to complete before continuing.
	value_ptr is a pointer to the value that is changed by the pthread function.

	Never reference anything on the pthread's stack, ie stuff in its function.

LOCKS

	int pthread_mutex_lock (pthread_mutex_t* mutex);
	int pthread_mutex_unlock (pthread_mutex_t* mutex);

		Put these before and after critical sections in code.
		These functions return 0 on success.

	pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
	OR
	pthread_mutex_t lock;
	int rc = pthread_mutex_init(&lock, NULL); //second argument is attributes
	assert(rc == 0);

	In the above, a thread will simply wait until critical section is unlocked.

	int pthread_mutex_trylock (pthread_mutex_t* mutex);
		Tries, and if it's locked, simply moves on.

	int pthread_mutex_timedlock (pthread_mutex_t* mutex, struct timespec* abs_timeout);
		Waits for abs_timeout before moving on.

CONDITION VARIABLE

	int pthread_cond_wait (pthread_cond_t* cond, pthread_mutex_t* mutex);
	int pthread_cond_signal (pthread_cond_t* cond);

	pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

	The wait function happens within a critical section between mutex lock and unlock.
	Calling this function will make it sleep until
	The signal function is called by another thread

When compiling a progrma with the pthread.h library, you have to explicitly include the -pthread flag when compiling.