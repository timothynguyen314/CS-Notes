MEMORY MANAGEMENT

goals:
transparency - hide limitations of physical memory
efficiency, protection/isolation

We use virtual addresses, not physical addresses.
The virtual address space only contains processes. It does not contain the OS.

Problems:
	Total data exceeds physical memory.
	Most processes don't know their size.
	Data must be persistent.
	Switches must be fast.

Fixed Partition Allocations
	Pre allocate partitions for processes, only certain sizes
	Very easy to allocate/deallocate
	Used in old batch systems
	Used a lot for transient uses
	Registers hold values - only memory within these address values can be used
	Problems:
		you don't know how much memory you'll use, so you're limited
		lots of internal fragmentation

Dynamic Partition Allocation
	Variable sized
	Partitions can be shared by processes
	Processes can have multiple partitions
	Problems:
		still limited by the size of physical memory
		much harder to relocate and expand processes
		subject to external fragmentation

You can't relocate contents of a partition, b/c pointers will still be pointing to the original partition.
You can't expand (ask for more space in the partition) b/c all other partitions that were already allocated can't be moved to make more room.
"heap" is a free list of memory, a linked list. Each has a descriptor of size and pointer to next chunk.
Strategies: best fit, worst fit, first fit, next fit

Buffer Pools
	special pools for fixed size buffers that are called a lot
	reduces external fragmentation and internal fragmentation if pools perfectly match
	we can dynamically size the list if we're using too much space or we need more space

Garbage Collection
	Fight memory leaks, targeting to free
	Find pointers, make sure they're pointing to something. Free all objects w/o a pointer.

Compaction
	moving all used memory to one end, and freeing space on the other end.

We need relocation, which is difficult due to pointers, and so we need to make processes location indpedendent.
"segment base registers" point to the start of a segment. Changing locations changes these values. All addresses and pointers merely add to those values.
"length/limit register" makes sure you don't access outside segment.