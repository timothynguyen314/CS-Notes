GARBAGE COLLECTION

close(), free(), delete(), exit() and returning from a function all free up resources
A resource manajer keeps track of all references to an object.
When the # of references to an object = 0, we free the object.

However, it is possible to copy references w/o the OS knowing.
Keeping track of this too costs overhead.
And of course some languages don't explicitly free.

Garbage collection - when resources are not explicitly freed when resources are becoming small, initiate the Garbage Collector
	-look through the resource list
	-free resources w/o references

Languages that use garbage collection must have unique data structures associated w references to easily scan for references.
Garbage collection uses a lot of CPU cycles.

We want to combat external fragmentationg.
Defragmentation changes what resources are allocated.
NAND flash will find a big 64MB block, move all the stuff being used to somewhere else and better allocate them, then erase everything else in the 64 MB block.
Disk space works in a similar manner.